#!/bin/bash

USAGE="$0 [-r=x] [-b=y] branch1 branch2 test [test ...]"

OPTS=$(getopt r:b:h "$*")

if [ $? != 0 ] ; then echo "Failed parsing options." >&2 ; exit 1 ; fi

eval set -- "$OPTS"

runs=3
batch=1

while true; do
    case "$1" in
    -h)
      echo "$USAGE"
      exit 0
      ;;
    -r)
      runs=$2
      shift 2
      ;;
    -b)
      batch=$2
      shift 2
      ;;
    --) shift; break ;;
    *) echo "$USAGE"; exit 1; ;;
    esac
done

if [ "$#" -le 2 ]; then
    echo "illegal number of parameters"
    echo "$USAGE"
    exit 2
fi

b1=$1
b2=$2
shift
shift

jobid=$(uuidgen)

#TODO can we put job id into db, so that we can limit results to just this run.

dirty=$(git status --porcelain | perl -ne '/^ M (.*)/&& print "$1, "')
if [ "$dirty" ]
then
  echo "Workspace not clean"
  exit 1
fi

make clean

git checkout "$b1"

make pc pc_fre

./perf.pl --batch "$batch" --runs "$runs" "$jobid" "$@"

make clean

git checkout "$b2"

make pc pc_fre

./perf.pl --batch "$batch" --runs "$runs" "$jobid" "$@"

#TODO we should not query on branch, use hash instead.
read -r -d '' sql <<- _EOM_
	create table perf(job text, branch text, commit_hash text, dirty text, test text, real float, user float, sys float);
	.separator ","
	.import perf.csv perf
	select b1.test,b2.rt-b1.rt, cast(100*(b2.rt-b1.rt)/b1.rt as int) from (select test,avg(real) as rt from perf where branch='${b1}' and job='${jobid}' group by branch,test) as b1 inner join (select test,avg(real) as rt from perf where branch='${b2}' and job='${jobid}' group by branch,test) as b2 on b1.test = b2.test;
_EOM_

#TODO could be nice to get stddev of tests.
echo "$sql" | sqlite3

